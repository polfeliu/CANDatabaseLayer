#include "DatabaseLayer.h"
#include "stdbool.h"
#include "FreeRTOS.h"
#include "task.h"
/*[[[cog
import cog
if settings['CallbackLib'] is not None:
    cog.outl("""#include "%s.h" """ % (settings['CallbackLib']))
]]]*/
//[[[end]]]

uint64_t reverseBits(uint64_t num, uint8_t NO_OF_BITS)
{
    uint64_t reverse_num = 0;
    uint64_t temp = num;
    uint64_t pos = (uint64_t)1 << (NO_OF_BITS - 1);
    while(pos != 0)
    {
        if(temp & 1)
            reverse_num |= pos;

        temp = temp >> 1;
        pos = pos >> 1;
    }

    return reverse_num;
}

/*[[[cog
import cog
if settings['FreeRTOSInteractionLayer']:
    cog.out("""
/*
 * Interaction Layer: Tasks to send the cyclic messages
 */
        """);

    for time, ILframes in InteractionLayer.items():
        cog.out("""
static void vTaskInteractionLayer_%s_%sms( void *pvParameters ){
    const TickType_t xTimeIncrement = pdMS_TO_TICKS(%s);
    TickType_t xLastWakeTime = xTaskGetTickCount();
    for(;;){
""" %(prefix, time, time));

        for frame in ILframes:
            cog.out("""
        %s_%s.send();""" %(prefix, frame))
    
        cog.out("""

        vTaskDelayUntil(&xLastWakeTime, xTimeIncrement);
    }
}
    """);

]]]*/
//[[[end]]]


/*[[[cog
import cog
if settings['FreeRTOSInteractionLayer']:
    cog.out("""
/*
 * Interaction Layer: Start function to initialize the cyclic tasks
 */
        """);

    cog.out("""
void %s_InteractionLayerInit(){
    """ % prefix)

    for time, ILframes in InteractionLayer.items():
        cog.out("""

    xTaskCreate(
        vTaskInteractionLayer_%s_%sms,      /* Function that implements the task. */
        "InteractionLayer_%s_%sms",         /* Text name for the task. */
        100,                                /* Stack size in words, not bytes. */
        NULL,                               /* Parameter passed into the task. */
        tskIDLE_PRIORITY,                   /* Priority at which the task is created. */
        NULL                                /* Used to pass out the created task's handle. */
    );      
    """ % (prefix, time, prefix, time))

    cog.out("""}""")
]]]*/
//[[[end]]]



/*
 * CAN Callbacks: Receive Callback function. This function should be called when a new message arrives. The function automatically identifies the message and unpacks it into the signals
 */
/*[[[cog
import cog
if settings['CallbackLib'] is not None:
    cog.out(
"""
void CAN1_ReceiveCallback(uint64_t data, uint32_t ID, bool is_extended, uint8_t DLC){
    if((ID > 0x1FFFFFFF) & is_extended){
        //invalid extended identifier
    }else if((ID > 0x7FF) & !is_extended){
        //invalid standard identifier
    }
""");

for framename, frame in frames.items():
    if frame['RX']:
        cog.out(
"""
    else if((ID==%s_%s.ID) & (is_extended==%s_%s.is_extended)){
        %s_%s.raw = data;
        %s_%s.receive();
    }
"""%(prefix, framename, prefix, framename, prefix, framename, prefix, framename, 
    ));
cog.out("""
    else{
        //ID is not received by this ECU
    }
}
""");
]]]*/
//[[[end]]]


/*
 * Signal getValue, setValue and setRaw method prototypes
 */

/*[[[cog
import cog
for signame, sig in signals.items():
    cog.outl(
"""static %s %ssig_%s_getValue();"""
    % (
        sig['getsetValue_type'],prefix,signame
    ));
    if sig['TX']:
        cog.outl(
"""static bool %ssig_%s_setValue(%s);"""
        % (
            prefix, signame, sig['getsetValue_type']
        ));

        cog.outl(
"""static void %ssig_%s_setRaw(%s);"""
        % (
            prefix, signame, sig['value_type']
        ));

]]]*/
//[[[end]]]


/*
 * Signals: Signal struct definitions
 */

/*[[[cog
import cog
for signame, sig in signals.items():
    cog.out(
"""
struct %ssig_%s_t %ssig_%s = {
    .length = %s,
    .byte_order = %s,
    .value_type = T%s,
    .unit = "%s",
    .initial_value = %s,
    .factor = %s,
    .offset = %s,
    .min = %s,
    .max = %s,
    .raw = %s,
    .getValue = %ssig_%s_getValue"""
    % (
        prefix, signame, prefix, signame,
        sig['length'],
        sig['byte_order'],
        sig['value_type'],
        sig['unit'],
        sig['initial_value'],
        sig['factor'],
        sig['offset'],
        sig['min'],
        sig['max'],
        sig['initial_value_raw'],
        prefix,signame,
    ));

    if sig["TX"]:
        cog.out(
    """,
    .setValue = %ssig_%s_setValue,
    .setRaw = %ssig_%s_setRaw"""
        % (
            prefix,signame,
            prefix,signame
        ));



    cog.out("""
};
    """)

]]]*/
//[[[end]]]

/*
 * Signals: Signal getValue and setValue private methods
 */
/*[[[cog
import cog
for signame, sig in signals.items():
    cog.outl("") #Space
    cog.out("""
// %s
""" % (signame))
    cog.out(
"""static %s %ssig_%s_getValue(){
"""%(sig['getsetValue_type'],prefix,signame));

    if settings['getsetValueOptimizeIdentity'] & (sig['factor'] == 1) & (sig['offset'] == 0):
        cog.out(
"""     return %ssig_%s.raw;
}
"""%(prefix,signame,));

    else:
        cog.out(
"""     return ((double) %ssig_%s.raw) * %ssig_%s.factor + %ssig_%s.offset;
}
"""% (prefix,signame,prefix,signame,prefix,signame));

    if sig['TX']:
        cog.out(
"""static bool %ssig_%s_setValue(%s val){
    bool saturation = false;"""%(prefix, signame, sig['getsetValue_type']));

        if settings['getsetValueOptimizeIdentity'] & (sig['factor'] == 1) & (sig['offset'] == 0):
            cog.out("""
    %ssig_%s.raw =  val;""" % (prefix, signame));

        else:
            cog.out("""
    if(val > %ssig_%s.max){
        saturation = true;
        val = %ssig_%s.max;
    }else if(val < %ssig_%s.min){
        saturation = true;
        val = %ssig_%s.min;
    }

    %ssig_%s.raw =  (val-%ssig_%s.offset)/%ssig_%s.factor;"""
        % (
            prefix, signame,
            prefix, signame,
            prefix, signame,
            prefix, signame,
            prefix, signame, prefix, signame, prefix, signame
        ));
    
        cog.out("""
    return !saturation;
}
""");

        cog.out(
"""static void %ssig_%s_setRaw(%s raw){
    %ssig_%s.raw = raw;
}"""%(
        prefix, signame, sig['value_type'],
        prefix, signame
        ));

]]]*/
//[[[end]]]

/*
 * Messages:  send and receive private methods
 */

/*[[[cog
import cog
def unpacksignal(framename, signalname, signal): 
    
    # signalraw = (rawmessage >> startbit) & mask

    prereversal = """(%s_%s.raw >> %s_%s.signals.%ssig_%s.startbit) & %s_%s.signals.%ssig_%s.mask""" % (
        prefix,framename,
        prefix,framename,prefix,signalname, 
        prefix,framename,prefix,signalname
    )
    
    
    if signal["byte_order"] == "little_endian":
        cog.out(
    """
    %ssig_%s.raw = %s;"""
        % (
            prefix,signalname, prereversal
        ));
    else: #big endian
        cog.out(
    """
    %ssig_%s.raw = reverseBits(%s, %ssig_%s.length);"""
        % (
            prefix,signalname, prereversal, 
            prefix,signalname,
        ));


def packsignal(framename, signalname, signal):
    # rawmessage |= ((uint64_t)signalraw&mask) << startbit
    if signal["byte_order"] == "little_endian":
        postreversal = "%ssig_%s.raw" % (prefix,signalname)
    else:
        postreversal = "reverseBits(%ssig_%s.raw,  %ssig_%s.length)" % (
            prefix,signalname,
            prefix,signalname
        )
    cog.out(
"""
    %s_%s.raw |= (uint64_t) ((uint64_t) %s & %s_%s.signals.%ssig_%s.mask) << %s_%s.signals.%ssig_%s.startbit;"""
        % (
             prefix, framename,
             postreversal,
             prefix,framename,prefix,signalname, 
             prefix,framename,prefix,signalname, 
        ));
        


# multiplex recursion inception :)
def expandmultiplex(framename, item, mode="rx"):
    multiplexorname = list(item)[0]
    if mode=='rx':
        unpacksignal(framename=framename, signalname=multiplexorname, signal=frame['signals'][multiplexorname]) #unpack multiplexor signal
    else:#tx
        packsignal(framename=framename, signalname=multiplexorname, signal=frame['signals'][multiplexorname]) #unpack multiplexor signal

    initialized = False
    cog.outl("")

    for multiplexvalue in list(item[multiplexorname]):
        subitem = item[multiplexorname][multiplexvalue]
        if len(subitem) ==0: # no signal associated to this value
            pass
        else:

            if not initialized:
                cog.out("""
    if(%ssig_%s.raw == %s){"""%(
                    prefix, multiplexorname, multiplexvalue
                    ))
                initialized = True;
            else:
                cog.out("""
    }else if(%ssig_%s.raw == %s){"""%(
                    prefix, multiplexorname, multiplexvalue
                    ))


            if type(subitem[0]) == str: # then it is a signal
                for multiplexedsignalname in subitem:
                    if mode=='rx':
                        unpacksignal(framename=framename, signalname=multiplexedsignalname, signal=frame['signals'][multiplexedsignalname])
                    else: #tx
                        packsignal(framename=framename, signalname=multiplexedsignalname, signal=frame['signals'][multiplexedsignalname])
            else:
                expandmultiplex(framename, subitem[0], mode=mode)


    cog.out("""
    }""")


for framename, frame in frames.items():
    if frame['RX']:
        cog.out(
"""
static void %s_%s_receive(){
"""
        % (
            prefix, framename
        ));


        for item in frame['signal_tree']:
            if type(item) == str: # then it is a signal
                unpacksignal(framename=framename, signalname=item, signal=frame['signals'][item])
            else:
                expandmultiplex(framename, item, mode="rx")


        cog.out("""
    
};""")
    if frame['TX']:
        cog.out(
"""
static void %s_%s_send(){
    %s_%s.raw = 0;
"""
        % (
            prefix, framename,
            prefix, framename
        ));

        for item in frame['signal_tree']:
            if type(item) == str: 
                packsignal(framename=framename, signalname=item, signal=frame['signals'][item])
            else:
                expandmultiplex(framename, item, mode='tx')
        
        cog.out("""
    %s_SendCallback(
        %s_%s.raw,
        %s_%s.ID,
        %s_%s.is_extended,
        %s_%s.DLC
    );
};"""%(
        prefix,
        prefix,framename,
        prefix,framename,
        prefix,framename,
        prefix,framename
    ));


]]]*/
//[[[end]]]

/*
 * Messages: Message struct definitions
 */


/*[[[cog
import cog
for framename, frame in frames.items():
    cog.out(
"""
// Comment: %s
struct %s_%s_t %s_%s = {
    .ID = %s, //dec: %s
    .is_extended = %s,
    .DLC = %s,
    .raw = 0,"""
    % (
        frame['comment'],
        prefix,framename,prefix,framename,
        frame['ID'], frame['decID'],
        frame['is_extended'],
        frame['DLC']
    ));

    if frame['RX']:
        cog.out("""
    .receive = %s_%s_receive,"""
        %(prefix, framename));

    if frame['TX']:
        cog.out("""
    .send = %s_%s_send,"""
        %(prefix, framename));

    cog.out("""
    .signals = {""");

    for signalname, sig in frame['signals'].items():
        if sig['RX']==False and sig['TX']==False:
            cog.outl("""
        //%s is not mapped to this ECU""" % (signalname))
        else:
            cog.out(
        """
        .%ssig_%s = {""" % (prefix,signalname))

            if sig['multiplexor'] is not None:
                cog.out(
        """
            .multiplexor = &%ssig_%s,
            .multiplexValues = %s,""" %(
                prefix, sig['multiplexor'],
                str(sig['multiplexValues']).replace("[", "{").replace("]", "}")
            ))

            cog.out(
        """
            .signal = &%ssig_%s,
            .startbit = %s,
            .mask = %s
        },
        """
        % (  
            prefix,signalname,
            sig['startbit'],
            sig['mask']
        ));

    cog.out("""
    }
};""")


]]]*/
//[[[end]]]

